\hypertarget{solver__main_8cu}{}\section{generic/solver\+\_\+main.cu File Reference}
\label{solver__main_8cu}\index{generic/solver\+\_\+main.\+cu@{generic/solver\+\_\+main.\+cu}}


the generic main file for all G\+PU solvers  


{\ttfamily \#include $<$stdlib.\+h$>$}\\*
{\ttfamily \#include $<$stdio.\+h$>$}\\*
{\ttfamily \#include $<$math.\+h$>$}\\*
{\ttfamily \#include $<$string.\+h$>$}\\*
{\ttfamily \#include $<$stdbool.\+h$>$}\\*
{\ttfamily \#include $<$complex.\+h$>$}\\*
{\ttfamily \#include $<$cuda.\+h$>$}\\*
{\ttfamily \#include $<$cuda\+\_\+runtime.\+h$>$}\\*
{\ttfamily \#include $<$helper\+\_\+cuda.\+h$>$}\\*
{\ttfamily \#include $<$cu\+Complex.\+h$>$}\\*
{\ttfamily \#include \char`\"{}header.\+cuh\char`\"{}}\\*
{\ttfamily \#include \char`\"{}timer.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}solver.\+cuh\char`\"{}}\\*
{\ttfamily \#include \char`\"{}gpu\+\_\+memory.\+cuh\char`\"{}}\\*
{\ttfamily \#include \char`\"{}read\+\_\+initial\+\_\+conditions.\+cuh\char`\"{}}\\*
{\ttfamily \#include \char`\"{}launch\+\_\+bounds.\+cuh\char`\"{}}\\*
{\ttfamily \#include $<$assert.\+h$>$}\\*
Include dependency graph for solver\+\_\+main.\+cu\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{solver__main_8cu__incl}
\end{center}
\end{figure}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{solver__main_8cu_a4f005e7918ecc7f1cd2424fb1708b2ca}{write\+\_\+log} (int N\+UM, double t, const double $\ast$y\+\_\+host, F\+I\+LE $\ast$p\+File)
\begin{DoxyCompactList}\small\item\em Writes state vectors to file. \end{DoxyCompactList}\item 
void \hyperlink{solver__main_8cu_a8baeaa804b9d16c49da2b8c74fbd6680}{memcpy2\+D\+\_\+in} (double $\ast$dst, const int pitch\+\_\+dst, double const $\ast$src, const int pitch\+\_\+src, const int offset, const size\+\_\+t width, const int height)
\begin{DoxyCompactList}\small\item\em A convienience method to copy memory between host pointers of different pitches, widths and heights. Enables easier use of C\+U\+DA\textquotesingle{}s cuda\+Memcpy2D functions. \end{DoxyCompactList}\item 
void \hyperlink{solver__main_8cu_acfaf06165e3e00cb81ebbcd80ee9c23f}{memcpy2\+D\+\_\+out} (double $\ast$dst, const int pitch\+\_\+dst, double const $\ast$src, const int pitch\+\_\+src, const int offset, const size\+\_\+t width, const int height)
\begin{DoxyCompactList}\small\item\em A convienience method to copy memory between host pointers of different pitches, widths and heights. Enables easier use of C\+U\+DA\textquotesingle{}s cuda\+Memcpy2D functions. \end{DoxyCompactList}\item 
int \hyperlink{solver__main_8cu_a0ddf1224851353fc92bfbff6f499fa97}{main} (int argc, char $\ast$argv\mbox{[}$\,$\mbox{]})
\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\+\_\+\+\_\+device\+\_\+\+\_\+ int \hyperlink{solver__main_8cu_a67cdbf6535bef9d8f0227e8340e7fe0a}{integrator\+\_\+steps} \mbox{[}\hyperlink{solver__options_8cuh_afd8c973bc66908100d15f47ae514ed41}{D\+I\+V\+E\+R\+G\+E\+N\+C\+E\+\_\+\+T\+E\+ST}\mbox{]} = \{0\}
\begin{DoxyCompactList}\small\item\em If \hyperlink{solver__options_8cuh_afd8c973bc66908100d15f47ae514ed41}{D\+I\+V\+E\+R\+G\+E\+N\+C\+E\+\_\+\+T\+E\+ST} is defined, this creates a device array for tracking. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
the generic main file for all G\+PU solvers 

\begin{DoxyAuthor}{Author}
Nicholas Curtis 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
03/09/2015
\end{DoxyDate}
Contains main function, setup, initialization, logging, timing and driver functions 

\subsection{Function Documentation}
\index{solver\+\_\+main.\+cu@{solver\+\_\+main.\+cu}!main@{main}}
\index{main@{main}!solver\+\_\+main.\+cu@{solver\+\_\+main.\+cu}}
\subsubsection[{\texorpdfstring{main(int argc, char $\ast$argv[])}{main(int argc, char *argv[])}}]{\setlength{\rightskip}{0pt plus 5cm}int main (
\begin{DoxyParamCaption}
\item[{int}]{argc, }
\item[{char $\ast$}]{argv\mbox{[}$\,$\mbox{]}}
\end{DoxyParamCaption}
)}\hypertarget{solver__main_8cu_a0ddf1224851353fc92bfbff6f499fa97}{}\label{solver__main_8cu_a0ddf1224851353fc92bfbff6f499fa97}
Main function


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em argc} & command line argument count \\
\hline
\mbox{\tt in}  & {\em argv} & command line argument vector\\
\hline
\end{DoxyParams}
This allows running the integrators from the command line. The syntax is as follows\+:~\newline
{\ttfamily ./solver-\/name \mbox{[}num\+\_\+threads\mbox{]} \mbox{[}num\+\_\+\+I\+V\+Ps\mbox{]}}~\newline

\begin{DoxyItemize}
\item num\+\_\+threads \mbox{[}Optional, Default\+:1\mbox{]}
\begin{DoxyItemize}
\item The number Open\+MP threads to utilize
\item The number of threads cannot be greater than recognized by Open\+MP via {\ttfamily omp\+\_\+get\+\_\+max\+\_\+threads()}
\end{DoxyItemize}
\item num\+\_\+\+I\+V\+Ps \mbox{[}Optional, Default\+:1\mbox{]}
\begin{DoxyItemize}
\item The number of initial value problems to solve.
\item This must be less than the number of conditions in the data file if \hyperlink{solver__options_8h_aa98acf0dc83a3dce3ba168d75a74cb1b}{S\+A\+M\+E\+\_\+\+IC} is not defined.
\item If \hyperlink{solver__options_8h_aa98acf0dc83a3dce3ba168d75a74cb1b}{S\+A\+M\+E\+\_\+\+IC} is defined, then the initial conditions in the mechanism files will be used. 
\end{DoxyItemize}
\end{DoxyItemize}Number of independent systems \index{solver\+\_\+main.\+cu@{solver\+\_\+main.\+cu}!memcpy2\+D\+\_\+in@{memcpy2\+D\+\_\+in}}
\index{memcpy2\+D\+\_\+in@{memcpy2\+D\+\_\+in}!solver\+\_\+main.\+cu@{solver\+\_\+main.\+cu}}
\subsubsection[{\texorpdfstring{memcpy2\+D\+\_\+in(double $\ast$dst, const int pitch\+\_\+dst, double const $\ast$src, const int pitch\+\_\+src, const int offset, const size\+\_\+t width, const int height)}{memcpy2D_in(double *dst, const int pitch_dst, double const *src, const int pitch_src, const int offset, const size_t width, const int height)}}]{\setlength{\rightskip}{0pt plus 5cm}void memcpy2\+D\+\_\+in (
\begin{DoxyParamCaption}
\item[{double $\ast$}]{dst, }
\item[{const int}]{pitch\+\_\+dst, }
\item[{double const $\ast$}]{src, }
\item[{const int}]{pitch\+\_\+src, }
\item[{const int}]{offset, }
\item[{const size\+\_\+t}]{width, }
\item[{const int}]{height}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{solver__main_8cu_a8baeaa804b9d16c49da2b8c74fbd6680}{}\label{solver__main_8cu_a8baeaa804b9d16c49da2b8c74fbd6680}


A convienience method to copy memory between host pointers of different pitches, widths and heights. Enables easier use of C\+U\+DA\textquotesingle{}s cuda\+Memcpy2D functions. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt out}  & {\em dst} & The destination array \\
\hline
\mbox{\tt in}  & {\em pitch\+\_\+dst} & The width (in bytes) of the destination array. This corresponds to the padded number of I\+V\+Ps to be solved. \\
\hline
\mbox{\tt in}  & {\em src} & The source pointer \\
\hline
\mbox{\tt in}  & {\em pitch\+\_\+src} & The width (in bytes) of the source array. This corresponds to the (non-\/padded) number of I\+V\+Ps read by read\+\_\+initial\+\_\+conditions \\
\hline
\mbox{\tt in}  & {\em offset} & The offset within the source array (I\+VP index) to copy from. This is useful in the case (for large models) where the solver and state vector memory will not fit in device memory and the integration must be split into multiple kernel calls. \\
\hline
\mbox{\tt in}  & {\em width} & The size (in bytes) of memory to copy for each entry in the state vector \\
\hline
\mbox{\tt in}  & {\em height} & The number of entries in the state vector \\
\hline
\end{DoxyParams}
\index{solver\+\_\+main.\+cu@{solver\+\_\+main.\+cu}!memcpy2\+D\+\_\+out@{memcpy2\+D\+\_\+out}}
\index{memcpy2\+D\+\_\+out@{memcpy2\+D\+\_\+out}!solver\+\_\+main.\+cu@{solver\+\_\+main.\+cu}}
\subsubsection[{\texorpdfstring{memcpy2\+D\+\_\+out(double $\ast$dst, const int pitch\+\_\+dst, double const $\ast$src, const int pitch\+\_\+src, const int offset, const size\+\_\+t width, const int height)}{memcpy2D_out(double *dst, const int pitch_dst, double const *src, const int pitch_src, const int offset, const size_t width, const int height)}}]{\setlength{\rightskip}{0pt plus 5cm}void memcpy2\+D\+\_\+out (
\begin{DoxyParamCaption}
\item[{double $\ast$}]{dst, }
\item[{const int}]{pitch\+\_\+dst, }
\item[{double const $\ast$}]{src, }
\item[{const int}]{pitch\+\_\+src, }
\item[{const int}]{offset, }
\item[{const size\+\_\+t}]{width, }
\item[{const int}]{height}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{solver__main_8cu_acfaf06165e3e00cb81ebbcd80ee9c23f}{}\label{solver__main_8cu_acfaf06165e3e00cb81ebbcd80ee9c23f}


A convienience method to copy memory between host pointers of different pitches, widths and heights. Enables easier use of C\+U\+DA\textquotesingle{}s cuda\+Memcpy2D functions. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt out}  & {\em dst} & The destination array \\
\hline
\mbox{\tt in}  & {\em pitch\+\_\+dst} & The width (in bytes) of the source array. This corresponds to the (non-\/padded) number of I\+V\+Ps read by read\+\_\+initial\+\_\+conditions \\
\hline
\mbox{\tt in}  & {\em src} & The source pointer \\
\hline
\mbox{\tt in}  & {\em pitch\+\_\+src} & The width (in bytes) of the destination array. This corresponds to the padded number of I\+V\+Ps to be solved. \\
\hline
\mbox{\tt in}  & {\em offset} & The offset within the destination array (I\+VP index) to copy to. This is useful in the case (for large models) where the solver and state vector memory will not fit in device memory and the integration must be split into multiple kernel calls. \\
\hline
\mbox{\tt in}  & {\em width} & The size (in bytes) of memory to copy for each entry in the state vector \\
\hline
\mbox{\tt in}  & {\em height} & The number of entries in the state vector \\
\hline
\end{DoxyParams}
\index{solver\+\_\+main.\+cu@{solver\+\_\+main.\+cu}!write\+\_\+log@{write\+\_\+log}}
\index{write\+\_\+log@{write\+\_\+log}!solver\+\_\+main.\+cu@{solver\+\_\+main.\+cu}}
\subsubsection[{\texorpdfstring{write\+\_\+log(int N\+U\+M, double t, const double $\ast$y\+\_\+host, F\+I\+L\+E $\ast$p\+File)}{write_log(int NUM, double t, const double *y_host, FILE *pFile)}}]{\setlength{\rightskip}{0pt plus 5cm}void write\+\_\+log (
\begin{DoxyParamCaption}
\item[{int}]{N\+UM, }
\item[{double}]{t, }
\item[{const double $\ast$}]{y\+\_\+host, }
\item[{F\+I\+LE $\ast$}]{p\+File}
\end{DoxyParamCaption}
)}\hypertarget{solver__main_8cu_a4f005e7918ecc7f1cd2424fb1708b2ca}{}\label{solver__main_8cu_a4f005e7918ecc7f1cd2424fb1708b2ca}


Writes state vectors to file. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em N\+UM} & the number of state vectors to write \\
\hline
\mbox{\tt in}  & {\em t} & the current system time \\
\hline
\mbox{\tt in}  & {\em y\+\_\+host} & the current state vectors \\
\hline
\mbox{\tt in}  & {\em p\+File} & the opened binary file object\\
\hline
\end{DoxyParams}
The resulting file is updated as\+: system time~\newline
temperature, mass fractions (State \#1)~\newline
temperature, mass fractions (State \#2)... 

\subsection{Variable Documentation}
\index{solver\+\_\+main.\+cu@{solver\+\_\+main.\+cu}!integrator\+\_\+steps@{integrator\+\_\+steps}}
\index{integrator\+\_\+steps@{integrator\+\_\+steps}!solver\+\_\+main.\+cu@{solver\+\_\+main.\+cu}}
\subsubsection[{\texorpdfstring{integrator\+\_\+steps}{integrator_steps}}]{\setlength{\rightskip}{0pt plus 5cm}\+\_\+\+\_\+device\+\_\+\+\_\+ int integrator\+\_\+steps\mbox{[}{\bf D\+I\+V\+E\+R\+G\+E\+N\+C\+E\+\_\+\+T\+E\+ST}\mbox{]} = \{0\}}\hypertarget{solver__main_8cu_a67cdbf6535bef9d8f0227e8340e7fe0a}{}\label{solver__main_8cu_a67cdbf6535bef9d8f0227e8340e7fe0a}


If \hyperlink{solver__options_8cuh_afd8c973bc66908100d15f47ae514ed41}{D\+I\+V\+E\+R\+G\+E\+N\+C\+E\+\_\+\+T\+E\+ST} is defined, this creates a device array for tracking. 

