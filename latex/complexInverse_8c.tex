\hypertarget{complexInverse_8c}{}\section{/home/nick/\+Dropbox/acceler\+Int/generic/complex\+Inverse.c File Reference}
\label{complexInverse_8c}\index{/home/nick/\+Dropbox/acceler\+Int/generic/complex\+Inverse.\+c@{/home/nick/\+Dropbox/acceler\+Int/generic/complex\+Inverse.\+c}}


Implementation of LU factorization of complex (variable-\/sized) matricies.  


{\ttfamily \#include $<$stdlib.\+h$>$}\\*
{\ttfamily \#include $<$stdio.\+h$>$}\\*
{\ttfamily \#include $<$math.\+h$>$}\\*
{\ttfamily \#include $<$float.\+h$>$}\\*
{\ttfamily \#include $<$complex.\+h$>$}\\*
{\ttfamily \#include $<$string.\+h$>$}\\*
{\ttfamily \#include \char`\"{}solver\+\_\+props.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}lapack\+\_\+dfns.\+h\char`\"{}}\\*
Include dependency graph for complex\+Inverse.\+c\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{complexInverse_8c__incl}
\end{center}
\end{figure}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
static int \hyperlink{complexInverse_8c_abddb9d0198f11d4a80fa4f4c25419c46}{get\+Hessenberg\+LU} (const int n, double complex $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+ A, int $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+ ind\+Pivot)
\begin{DoxyCompactList}\small\item\em Computes the LU factorization of a (n x S\+T\+R\+I\+DE) Hessenberg Matrix using partial pivoting with row interchanges. \end{DoxyCompactList}\item 
void \hyperlink{complexInverse_8c_abf5391e42443aa516eecd888b8837ced}{scale\+Complex} (const int n, const double complex val, double complex $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+ arrX)
\begin{DoxyCompactList}\small\item\em scale\+Complex scales a vector (with increment equal to one) by a constant val. \end{DoxyCompactList}\item 
void \hyperlink{complexInverse_8c_afab60c79bd7e7da7e6fd1d96ce74f42a}{multiply\+Complex\+Upper\+MV} (const int n, double complex $\ast$x, const int lda, const double complex $\ast$A)
\begin{DoxyCompactList}\small\item\em Performs the matrix-\/vector operation $x_v:= A*x_v$. \end{DoxyCompactList}\item 
void \hyperlink{complexInverse_8c_a30c78bcd7e780b95ac502f72fd1b432d}{complex\+G\+E\+MV} (const int m, const int n, const int lda, const double alpha, const double complex $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+ A, const double complex $\ast$arrX, double complex $\ast$arrY)
\begin{DoxyCompactList}\small\item\em Computes the matrix-\/vector operation $alpha*A*x + y$ where alpha is a scalar, x and y are vectors and A is an m by n matrix. \end{DoxyCompactList}\item 
int \hyperlink{complexInverse_8c_ab75b38ab553b5bd395319fb895d78202}{get\+Complex\+Inverse\+Hessenberg\+LU} (const int n, double complex $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+ A, const int $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+ ind\+Pivot)
\begin{DoxyCompactList}\small\item\em get\+Complex\+Inverse\+Hessenberg\+LU computes the inverse of a matrix using the LU factorization computed by get\+Hessenberg\+LU. \end{DoxyCompactList}\item 
void \hyperlink{complexInverse_8c_a1e979f4291088ac970fe8f6eb3376f9a}{get\+Complex\+Inverse\+Hessenberg} (const int n, double complex $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+ A, int $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+ ipiv, int $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+ info)
\begin{DoxyCompactList}\small\item\em get\+Complex\+Inverse\+Hessenberg computes the inverse of an upper Hessenberg matrix A using a LU factorization method \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Implementation of LU factorization of complex (variable-\/sized) matricies. 

Adapted from \href{http://www.netlib.org/lapack/}{\tt Lapack} LU factorization and inversion routines 

\subsection{Function Documentation}
\index{complex\+Inverse.\+c@{complex\+Inverse.\+c}!complex\+G\+E\+MV@{complex\+G\+E\+MV}}
\index{complex\+G\+E\+MV@{complex\+G\+E\+MV}!complex\+Inverse.\+c@{complex\+Inverse.\+c}}
\subsubsection[{\texorpdfstring{complex\+G\+E\+M\+V(const int m, const int n, const int lda, const double alpha, const double complex $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+ A, const double complex $\ast$arr\+X, double complex $\ast$arr\+Y)}{complexGEMV(const int m, const int n, const int lda, const double alpha, const double complex *__restrict__ A, const double complex *arrX, double complex *arrY)}}]{\setlength{\rightskip}{0pt plus 5cm}void complex\+G\+E\+MV (
\begin{DoxyParamCaption}
\item[{const int}]{m, }
\item[{const int}]{n, }
\item[{const int}]{lda, }
\item[{const double}]{alpha, }
\item[{const double complex $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+}]{A, }
\item[{const double complex $\ast$}]{arrX, }
\item[{double complex $\ast$}]{arrY}
\end{DoxyParamCaption}
)}\hypertarget{complexInverse_8c_a30c78bcd7e780b95ac502f72fd1b432d}{}\label{complexInverse_8c_a30c78bcd7e780b95ac502f72fd1b432d}


Computes the matrix-\/vector operation $alpha*A*x + y$ where alpha is a scalar, x and y are vectors and A is an m by n matrix. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em m} & On entry, M specifies the number of rows of the matrix A. Must be $>$= 0 \\
\hline
\mbox{\tt out}  & {\em n} & On entry, N specifies the number of columns of the matrix A. Must be $>$= 0 \\
\hline
\mbox{\tt in}  & {\em lda} & The stride of the matrix \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{exprb43__props_8h_a351d54267048643c4365f6a24641d0cf}{S\+T\+R\+I\+DE} 
\end{DoxySeeAlso}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em alpha} & The scalar value \\
\hline
\mbox{\tt in}  & {\em A} & A is an array of dimension (lda, n). Before entry, the leading m by n part of the array A must contain the matrix of coefficients. \\
\hline
\mbox{\tt in}  & {\em arrX} & arrX is an array of dimension at least (n) Before entry, the incremented array arrX must contain the vector x. \\
\hline
\mbox{\tt in,out}  & {\em arrY} & arrY is an array of dimension at least (m). Before entry, the incremented array arrY must contain the vector y. On exit, arrY is overwritten by the updated vector y.\\
\hline
\end{DoxyParams}
Note\+: These pointers cannot use the \+\_\+\+\_\+restrict\+\_\+\+\_\+ modifier, as they may overlap \index{complex\+Inverse.\+c@{complex\+Inverse.\+c}!get\+Complex\+Inverse\+Hessenberg@{get\+Complex\+Inverse\+Hessenberg}}
\index{get\+Complex\+Inverse\+Hessenberg@{get\+Complex\+Inverse\+Hessenberg}!complex\+Inverse.\+c@{complex\+Inverse.\+c}}
\subsubsection[{\texorpdfstring{get\+Complex\+Inverse\+Hessenberg(const int n, double complex $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+ A, int $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+ ipiv, int $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+ info)}{getComplexInverseHessenberg(const int n, double complex *__restrict__ A, int *__restrict__ ipiv, int *__restrict__ info)}}]{\setlength{\rightskip}{0pt plus 5cm}void get\+Complex\+Inverse\+Hessenberg (
\begin{DoxyParamCaption}
\item[{const int}]{n, }
\item[{double complex $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+}]{A, }
\item[{int $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+}]{ipiv, }
\item[{int $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+}]{info}
\end{DoxyParamCaption}
)}\hypertarget{complexInverse_8c_a1e979f4291088ac970fe8f6eb3376f9a}{}\label{complexInverse_8c_a1e979f4291088ac970fe8f6eb3376f9a}


get\+Complex\+Inverse\+Hessenberg computes the inverse of an upper Hessenberg matrix A using a LU factorization method 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em n} & The order of the matrix A. n $>$= 0. \\
\hline
\mbox{\tt in,out}  & {\em A} & The array, dimension (S\+T\+R\+I\+DE, n) \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{exprb43__props_8h_a351d54267048643c4365f6a24641d0cf}{S\+T\+R\+I\+DE} 
\end{DoxySeeAlso}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt out}  & {\em ipiv} & ipiv is an array of dimension (n). The pivot indices from get\+Hessenberg\+LU; for 0$<$=i$<$=n-\/1, row i of the matrix was interchanged with row ind\+Piv\mbox{[}i\mbox{]}. \\
\hline
\mbox{\tt out}  & {\em info} & If not zero, an error occured during factorization \\
\hline
\end{DoxyParams}
\index{complex\+Inverse.\+c@{complex\+Inverse.\+c}!get\+Complex\+Inverse\+Hessenberg\+LU@{get\+Complex\+Inverse\+Hessenberg\+LU}}
\index{get\+Complex\+Inverse\+Hessenberg\+LU@{get\+Complex\+Inverse\+Hessenberg\+LU}!complex\+Inverse.\+c@{complex\+Inverse.\+c}}
\subsubsection[{\texorpdfstring{get\+Complex\+Inverse\+Hessenberg\+L\+U(const int n, double complex $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+ A, const int $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+ ind\+Pivot)}{getComplexInverseHessenbergLU(const int n, double complex *__restrict__ A, const int *__restrict__ indPivot)}}]{\setlength{\rightskip}{0pt plus 5cm}int get\+Complex\+Inverse\+Hessenberg\+LU (
\begin{DoxyParamCaption}
\item[{const int}]{n, }
\item[{double complex $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+}]{A, }
\item[{const int $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+}]{ind\+Pivot}
\end{DoxyParamCaption}
)}\hypertarget{complexInverse_8c_ab75b38ab553b5bd395319fb895d78202}{}\label{complexInverse_8c_ab75b38ab553b5bd395319fb895d78202}


get\+Complex\+Inverse\+Hessenberg\+LU computes the inverse of a matrix using the LU factorization computed by get\+Hessenberg\+LU. 

This method inverts U and then computes inv(\+A) by solving the system inv(\+A)$\ast$L = inv(\+U) for inv(\+A).


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em n} & The order of the matrix A. n $>$= 0. \\
\hline
\mbox{\tt in,out}  & {\em A} & The array, dimension (S\+T\+R\+I\+DE, n) \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{exprb43__props_8h_a351d54267048643c4365f6a24641d0cf}{S\+T\+R\+I\+DE} 
\end{DoxySeeAlso}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em ind\+Pivot} & ind\+Pivot is an array of dimension (n). The pivot indices from get\+Hessenberg\+LU; for 0$<$=i$<$=n-\/1, row i of the matrix was interchanged with row ind\+Piv\mbox{[}i\mbox{]}. \\
\hline
\end{DoxyParams}
\index{complex\+Inverse.\+c@{complex\+Inverse.\+c}!get\+Hessenberg\+LU@{get\+Hessenberg\+LU}}
\index{get\+Hessenberg\+LU@{get\+Hessenberg\+LU}!complex\+Inverse.\+c@{complex\+Inverse.\+c}}
\subsubsection[{\texorpdfstring{get\+Hessenberg\+L\+U(const int n, double complex $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+ A, int $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+ ind\+Pivot)}{getHessenbergLU(const int n, double complex *__restrict__ A, int *__restrict__ indPivot)}}]{\setlength{\rightskip}{0pt plus 5cm}static int get\+Hessenberg\+LU (
\begin{DoxyParamCaption}
\item[{const int}]{n, }
\item[{double complex $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+}]{A, }
\item[{int $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+}]{ind\+Pivot}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\hypertarget{complexInverse_8c_abddb9d0198f11d4a80fa4f4c25419c46}{}\label{complexInverse_8c_abddb9d0198f11d4a80fa4f4c25419c46}


Computes the LU factorization of a (n x S\+T\+R\+I\+DE) Hessenberg Matrix using partial pivoting with row interchanges. 

\begin{DoxySeeAlso}{See also}
\hyperlink{exprb43__props_8h_a351d54267048643c4365f6a24641d0cf}{S\+T\+R\+I\+DE} 
\end{DoxySeeAlso}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em n} & The matrix size \\
\hline
\mbox{\tt in,out}  & {\em A} & The matrix to factorize (nxn) with stride defined in \hyperlink{solver__props_8h}{solver\+\_\+props.\+h} \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{exprb43__props_8h_a351d54267048643c4365f6a24641d0cf}{S\+T\+R\+I\+DE} 
\end{DoxySeeAlso}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt out}  & {\em ind\+Pivot} & ind\+Pivot is an array of dimension (n). The pivot indices from get\+Hessenberg\+LU; for 0$<$=i$<$=n-\/1, row i of the matrix was interchanged with row ind\+Piv\mbox{[}i\mbox{]}.\\
\hline
\end{DoxyParams}
The factorization has the form\+: $A = P * L * U$ where P is a permutation matrix, L is lower triangular with unit diagonal elements (lower trapezoidal if m $>$ n), and U is upper triangular (upper trapezoidal if m $<$ n). For full reference see\+: G. W. Stewart, Matrix Algorithms\+: Volume 1\+: Basic Decompositions, S\+I\+AM, Philadelphia, 1998. doi\+:10.\+1137/1.9781611971408. \index{complex\+Inverse.\+c@{complex\+Inverse.\+c}!multiply\+Complex\+Upper\+MV@{multiply\+Complex\+Upper\+MV}}
\index{multiply\+Complex\+Upper\+MV@{multiply\+Complex\+Upper\+MV}!complex\+Inverse.\+c@{complex\+Inverse.\+c}}
\subsubsection[{\texorpdfstring{multiply\+Complex\+Upper\+M\+V(const int n, double complex $\ast$x, const int lda, const double complex $\ast$\+A)}{multiplyComplexUpperMV(const int n, double complex *x, const int lda, const double complex *A)}}]{\setlength{\rightskip}{0pt plus 5cm}void multiply\+Complex\+Upper\+MV (
\begin{DoxyParamCaption}
\item[{const int}]{n, }
\item[{double complex $\ast$}]{x, }
\item[{const int}]{lda, }
\item[{const double complex $\ast$}]{A}
\end{DoxyParamCaption}
)}\hypertarget{complexInverse_8c_afab60c79bd7e7da7e6fd1d96ce74f42a}{}\label{complexInverse_8c_afab60c79bd7e7da7e6fd1d96ce74f42a}


Performs the matrix-\/vector operation $x_v:= A*x_v$. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em n} & On entry, n specifies the order of the matrix A. n must be at least zero. \\
\hline
\mbox{\tt out}  & {\em x} & x is an array of dimension at least (n). Before entry, the incremented array X must contain the n element vector $x_v$. On exit, X is overwritten with the transformed vector $x_v$. \\
\hline
\mbox{\tt in}  & {\em lda} & The stride of the matrix \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{exprb43__props_8h_a351d54267048643c4365f6a24641d0cf}{S\+T\+R\+I\+DE} 
\end{DoxySeeAlso}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em A} & A is an array of dimension (lda, n). Before entry the leading n by n upper triangular part of the array A must contain the upper triangular matrix and the strictly lower triangular part of A is not referenced.\\
\hline
\end{DoxyParams}
Note\+: These pointers can\textquotesingle{}t use the \+\_\+\+\_\+restrict\+\_\+\+\_\+ attribute, as they may overlap \index{complex\+Inverse.\+c@{complex\+Inverse.\+c}!scale\+Complex@{scale\+Complex}}
\index{scale\+Complex@{scale\+Complex}!complex\+Inverse.\+c@{complex\+Inverse.\+c}}
\subsubsection[{\texorpdfstring{scale\+Complex(const int n, const double complex val, double complex $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+ arr\+X)}{scaleComplex(const int n, const double complex val, double complex *__restrict__ arrX)}}]{\setlength{\rightskip}{0pt plus 5cm}void scale\+Complex (
\begin{DoxyParamCaption}
\item[{const int}]{n, }
\item[{const double complex}]{val, }
\item[{double complex $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+}]{arrX}
\end{DoxyParamCaption}
)}\hypertarget{complexInverse_8c_abf5391e42443aa516eecd888b8837ced}{}\label{complexInverse_8c_abf5391e42443aa516eecd888b8837ced}


scale\+Complex scales a vector (with increment equal to one) by a constant val. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em n} & The vector size \\
\hline
\mbox{\tt out}  & {\em val} & The value to scale by \\
\hline
\mbox{\tt out}  & {\em arrX} & The vector to scale \\
\hline
\end{DoxyParams}
