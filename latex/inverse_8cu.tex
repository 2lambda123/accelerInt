\hypertarget{inverse_8cu}{}\section{/home/nick/\+Dropbox/acceler\+Int/generic/inverse.cu File Reference}
\label{inverse_8cu}\index{/home/nick/\+Dropbox/acceler\+Int/generic/inverse.\+cu@{/home/nick/\+Dropbox/acceler\+Int/generic/inverse.\+cu}}


C\+U\+DA LU decomposition implementation.  


{\ttfamily \#include $<$stdlib.\+h$>$}\\*
{\ttfamily \#include $<$math.\+h$>$}\\*
{\ttfamily \#include $<$float.\+h$>$}\\*
{\ttfamily \#include $<$string.\+h$>$}\\*
{\ttfamily \#include \char`\"{}header.\+cuh\char`\"{}}\\*
{\ttfamily \#include \char`\"{}solver\+\_\+props.\+cuh\char`\"{}}\\*
Include dependency graph for inverse.\+cu\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{inverse_8cu__incl}
\end{center}
\end{figure}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\+\_\+\+\_\+device\+\_\+\+\_\+ int \hyperlink{inverse_8cu_a7b3d468c8500704ef2452f40b23810bb}{get\+Max} (const int n, const double $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+ Arr)
\begin{DoxyCompactList}\small\item\em get\+Max finds the index of the first element having maximum absolute value. \end{DoxyCompactList}\item 
\+\_\+\+\_\+device\+\_\+\+\_\+ void \hyperlink{inverse_8cu_adbb4f3f3af5f968a94f717729803c88d}{scale} (const int n, const double val, double $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+ arrX)
\begin{DoxyCompactList}\small\item\em scale multiplies a vector (with increment equal to one) by a constant val. \end{DoxyCompactList}\item 
\+\_\+\+\_\+device\+\_\+\+\_\+ void \hyperlink{inverse_8cu_adac70ba85b61598b9fcee8a381eed708}{swap} (const int n, double $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+ arrX, const int incX, double $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+ arrY, const int incY)
\begin{DoxyCompactList}\small\item\em interchanges two vectors arrX and arrY. \end{DoxyCompactList}\item 
\+\_\+\+\_\+device\+\_\+\+\_\+ void \hyperlink{inverse_8cu_a8dbfcd45123f24c8d64e2049ae2782fe}{G\+E\+RU} (const int n, const double alpha, const double $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+ arrX, const double $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+ arrY, const int incY, double $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+ A, const int lda)
\begin{DoxyCompactList}\small\item\em G\+E\+RU performs the rank 1 operation $A := alpha * arrX * arrY **T + A$ where alpha is a scalar, arrX and arrY are n element vectors, and A is a (lda x n) matrix. \end{DoxyCompactList}\item 
\+\_\+\+\_\+device\+\_\+\+\_\+ void \hyperlink{inverse_8cu_a25bf32c703aa4b2a43131df214ee0375}{get\+LU} (const int n, double $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+ A, int $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+ ind\+Pivot, int $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+ info)
\begin{DoxyCompactList}\small\item\em Computes the LU factorization of a (n x n) matrix using partial pivoting with row interchanges. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
C\+U\+DA LU decomposition implementation. 



\subsection{Function Documentation}
\index{inverse.\+cu@{inverse.\+cu}!G\+E\+RU@{G\+E\+RU}}
\index{G\+E\+RU@{G\+E\+RU}!inverse.\+cu@{inverse.\+cu}}
\subsubsection[{\texorpdfstring{G\+E\+R\+U(const int n, const double alpha, const double $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+ arr\+X, const double $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+ arr\+Y, const int inc\+Y, double $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+ A, const int lda)}{GERU(const int n, const double alpha, const double *__restrict__ arrX, const double *__restrict__ arrY, const int incY, double *__restrict__ A, const int lda)}}]{\setlength{\rightskip}{0pt plus 5cm}\+\_\+\+\_\+device\+\_\+\+\_\+ void G\+E\+RU (
\begin{DoxyParamCaption}
\item[{const int}]{n, }
\item[{const double}]{alpha, }
\item[{const double $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+}]{arrX, }
\item[{const double $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+}]{arrY, }
\item[{const int}]{incY, }
\item[{double $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+}]{A, }
\item[{const int}]{lda}
\end{DoxyParamCaption}
)}\hypertarget{inverse_8cu_a8dbfcd45123f24c8d64e2049ae2782fe}{}\label{inverse_8cu_a8dbfcd45123f24c8d64e2049ae2782fe}


G\+E\+RU performs the rank 1 operation $A := alpha * arrX * arrY **T + A$ where alpha is a scalar, arrX and arrY are n element vectors, and A is a (lda x n) matrix. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em n} & The matrix/vector size \\
\hline
\mbox{\tt in}  & {\em alpha} & The value to scale by \\
\hline
\mbox{\tt in}  & {\em arrX} & arrX is an array of dimension at least n. Before entry, the incremented array arrX must contain the n element vector x. \\
\hline
\mbox{\tt in}  & {\em arrY} & arrY is an array of dimension at least 1 + (n -\/ 1) $\ast$ incY. Before entry, the incremented array arrY must contain the n element vector y. \\
\hline
\mbox{\tt in}  & {\em incY} & On entry, I\+N\+CY specifies the increment for the elements of arrY. incY must not be zero. \\
\hline
\mbox{\tt out}  & {\em A} & A is an array of dimension (lda x n). Before entry, the leading n by n part of the array A must contain the matrix of coefficients. On exit, A is overwritten by the updated matrix. \\
\hline
\mbox{\tt in}  & {\em lda} & On entry, lda specifies the first dimension of A as declared in the calling (sub) program. lda must be at least max( 1, n ). \\
\hline
\end{DoxyParams}
\index{inverse.\+cu@{inverse.\+cu}!get\+LU@{get\+LU}}
\index{get\+LU@{get\+LU}!inverse.\+cu@{inverse.\+cu}}
\subsubsection[{\texorpdfstring{get\+L\+U(const int n, double $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+ A, int $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+ ind\+Pivot, int $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+ info)}{getLU(const int n, double *__restrict__ A, int *__restrict__ indPivot, int *__restrict__ info)}}]{\setlength{\rightskip}{0pt plus 5cm}\+\_\+\+\_\+device\+\_\+\+\_\+ void get\+LU (
\begin{DoxyParamCaption}
\item[{const int}]{n, }
\item[{double $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+}]{A, }
\item[{int $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+}]{ind\+Pivot, }
\item[{int $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+}]{info}
\end{DoxyParamCaption}
)}\hypertarget{inverse_8cu_a25bf32c703aa4b2a43131df214ee0375}{}\label{inverse_8cu_a25bf32c703aa4b2a43131df214ee0375}


Computes the LU factorization of a (n x n) matrix using partial pivoting with row interchanges. 

\begin{DoxySeeAlso}{See also}
\hyperlink{exprb43__props_8h_a351d54267048643c4365f6a24641d0cf}{S\+T\+R\+I\+DE} 
\end{DoxySeeAlso}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em n} & The matrix size \\
\hline
\mbox{\tt in,out}  & {\em A} & The matrix to factorize (n x n) with stride defined in \hyperlink{solver__props_8h}{solver\+\_\+props.\+h} \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{exprb43__props_8h_a351d54267048643c4365f6a24641d0cf}{S\+T\+R\+I\+DE} 
\end{DoxySeeAlso}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt out}  & {\em ind\+Pivot} & ind\+Pivot is an array of dimension (n). The pivot indices from get\+Hessenberg\+LU; for 0$<$=i$<$=n-\/1, row i of the matrix was interchanged with row ind\+Piv\mbox{[}i\mbox{]}. \& \\
\hline
\mbox{\tt out}  & {\em info} & An information variable\\
\hline
\end{DoxyParams}
The factorization has the form\+: $A = P * L * U$ where P is a permutation matrix, L is lower triangular with unit diagonal elements (lower trapezoidal if m $>$ n), and U is upper triangular (upper trapezoidal if m $<$ n). \index{inverse.\+cu@{inverse.\+cu}!get\+Max@{get\+Max}}
\index{get\+Max@{get\+Max}!inverse.\+cu@{inverse.\+cu}}
\subsubsection[{\texorpdfstring{get\+Max(const int n, const double $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+ Arr)}{getMax(const int n, const double *__restrict__ Arr)}}]{\setlength{\rightskip}{0pt plus 5cm}\+\_\+\+\_\+device\+\_\+\+\_\+ int get\+Max (
\begin{DoxyParamCaption}
\item[{const int}]{n, }
\item[{const double $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+}]{Arr}
\end{DoxyParamCaption}
)}\hypertarget{inverse_8cu_a7b3d468c8500704ef2452f40b23810bb}{}\label{inverse_8cu_a7b3d468c8500704ef2452f40b23810bb}


get\+Max finds the index of the first element having maximum absolute value. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em n} & The size of Arr \\
\hline
\mbox{\tt in}  & {\em Arr} & The (nx1) vector to determine the maximum value of \\
\hline
\end{DoxyParams}
\index{inverse.\+cu@{inverse.\+cu}!scale@{scale}}
\index{scale@{scale}!inverse.\+cu@{inverse.\+cu}}
\subsubsection[{\texorpdfstring{scale(const int n, const double val, double $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+ arr\+X)}{scale(const int n, const double val, double *__restrict__ arrX)}}]{\setlength{\rightskip}{0pt plus 5cm}\+\_\+\+\_\+device\+\_\+\+\_\+ void scale (
\begin{DoxyParamCaption}
\item[{const int}]{n, }
\item[{const double}]{val, }
\item[{double $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+}]{arrX}
\end{DoxyParamCaption}
)}\hypertarget{inverse_8cu_adbb4f3f3af5f968a94f717729803c88d}{}\label{inverse_8cu_adbb4f3f3af5f968a94f717729803c88d}


scale multiplies a vector (with increment equal to one) by a constant val. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em n} & The vector size \\
\hline
\mbox{\tt out}  & {\em val} & The value to scale by \\
\hline
\mbox{\tt out}  & {\em arrX} & The vector to scale \\
\hline
\end{DoxyParams}
\index{inverse.\+cu@{inverse.\+cu}!swap@{swap}}
\index{swap@{swap}!inverse.\+cu@{inverse.\+cu}}
\subsubsection[{\texorpdfstring{swap(const int n, double $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+ arr\+X, const int inc\+X, double $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+ arr\+Y, const int inc\+Y)}{swap(const int n, double *__restrict__ arrX, const int incX, double *__restrict__ arrY, const int incY)}}]{\setlength{\rightskip}{0pt plus 5cm}\+\_\+\+\_\+device\+\_\+\+\_\+ void swap (
\begin{DoxyParamCaption}
\item[{const int}]{n, }
\item[{double $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+}]{arrX, }
\item[{const int}]{incX, }
\item[{double $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+}]{arrY, }
\item[{const int}]{incY}
\end{DoxyParamCaption}
)}\hypertarget{inverse_8cu_adac70ba85b61598b9fcee8a381eed708}{}\label{inverse_8cu_adac70ba85b61598b9fcee8a381eed708}


interchanges two vectors arrX and arrY. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em n} & the vector size \\
\hline
\mbox{\tt in}  & {\em arrX} & the first vector to swap \\
\hline
\mbox{\tt in}  & {\em incX} & the increment of the arrX vector \\
\hline
\mbox{\tt in}  & {\em arrY} & the second vector to swap \\
\hline
\mbox{\tt in}  & {\em incY} & the increment of the arrY vector \\
\hline
\end{DoxyParams}
