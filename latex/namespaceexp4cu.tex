\hypertarget{namespaceexp4cu}{}\section{exp4cu Namespace Reference}
\label{namespaceexp4cu}\index{exp4cu@{exp4cu}}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structexp4cu_1_1solver__memory}{solver\+\_\+memory}
\begin{DoxyCompactList}\small\item\em Structure containing memory needed for E\+X\+P4 algorithm. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\+\_\+\+\_\+device\+\_\+\+\_\+ void \hyperlink{namespaceexp4cu_aac3abe15ef50061cdfe24ed7d9d64b7a}{integrate} (const double t\+\_\+start, const double t\+\_\+end, const double pr, double $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+ y, const mechanism\+\_\+memory $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+ mech, const \hyperlink{structexp4cu_1_1solver__memory}{solver\+\_\+memory} $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+ solver)
\begin{DoxyCompactList}\small\item\em 4th-\/order exponential integrator function w/ adaptive Kyrlov subspace approximation \end{DoxyCompactList}\item 
void \hyperlink{namespaceexp4cu_abcdabb48b002afcaf4520f85bb06c156}{create\+And\+Zero} (void $\ast$$\ast$ptr, size\+\_\+t size)
\begin{DoxyCompactList}\small\item\em Convienvience method to Cuda Malloc and memset a pointer to zero. \end{DoxyCompactList}\item 
void \hyperlink{namespaceexp4cu_aa57e5681ad1b4e46c67d24d12d64e435}{initialize\+\_\+solver} (int padded, \hyperlink{structexp4cu_1_1solver__memory}{solver\+\_\+memory} $\ast$$\ast$h\+\_\+mem, \hyperlink{structexp4cu_1_1solver__memory}{solver\+\_\+memory} $\ast$$\ast$d\+\_\+mem)
\begin{DoxyCompactList}\small\item\em Initializes the G\+PU solver. \end{DoxyCompactList}\item 
const char $\ast$ \hyperlink{namespaceexp4cu_ad9fad26aa869ef1c6b7fc061e1e6abc3}{solver\+\_\+name} ()
\begin{DoxyCompactList}\small\item\em Returns a descriptive solver name. \end{DoxyCompactList}\item 
void \hyperlink{namespaceexp4cu_a042f555823c136890f60ab28454daf9e}{solver\+\_\+log} ()
\begin{DoxyCompactList}\small\item\em Executes solver specific logging tasks. \end{DoxyCompactList}\item 
void \hyperlink{namespaceexp4cu_a128b314d7c6b2521bbd64653dc8b9826}{init\+\_\+solver\+\_\+log} ()
\begin{DoxyCompactList}\small\item\em Initializes solver specific items for logging. \end{DoxyCompactList}\item 
size\+\_\+t \hyperlink{namespaceexp4cu_a4d5db66ace53978d01e1975e47e30655}{required\+\_\+solver\+\_\+size} ()
\begin{DoxyCompactList}\small\item\em Returns the total size (in bytes) required for memory storage for a single G\+PU thread Used in calculation of the maximum number of possible G\+PU threads to launch, this method returns the size of the \hyperlink{structexp4cu_1_1solver__memory}{solver\+\_\+memory} structure (per-\/\+G\+PU thread) \end{DoxyCompactList}\item 
void \hyperlink{namespaceexp4cu_aa775ac1fc1a96522483d9878718cdbf2}{cleanup\+\_\+solver} (\hyperlink{structexp4cu_1_1solver__memory}{solver\+\_\+memory} $\ast$$\ast$h\+\_\+mem, \hyperlink{structexp4cu_1_1solver__memory}{solver\+\_\+memory} $\ast$$\ast$d\+\_\+mem)
\begin{DoxyCompactList}\small\item\em Cleans up solver memory. \end{DoxyCompactList}\item 
\+\_\+\+\_\+host\+\_\+\+\_\+ void \hyperlink{namespaceexp4cu_a2d5234f5e9971aec336ac64ce719f1f4}{check\+\_\+error} (int num\+\_\+cond, int $\ast$codes)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Include common code. 

\subsection{Function Documentation}
\index{exp4cu@{exp4cu}!check\+\_\+error@{check\+\_\+error}}
\index{check\+\_\+error@{check\+\_\+error}!exp4cu@{exp4cu}}
\subsubsection[{\texorpdfstring{check\+\_\+error(int num\+\_\+cond, int $\ast$codes)}{check_error(int num_cond, int *codes)}}]{\setlength{\rightskip}{0pt plus 5cm}\+\_\+\+\_\+host\+\_\+\+\_\+ void exp4cu\+::check\+\_\+error (
\begin{DoxyParamCaption}
\item[{int}]{num\+\_\+cond, }
\item[{int $\ast$}]{codes}
\end{DoxyParamCaption}
)}\hypertarget{namespaceexp4cu_a2d5234f5e9971aec336ac64ce719f1f4}{}\label{namespaceexp4cu_a2d5234f5e9971aec336ac64ce719f1f4}
\index{exp4cu@{exp4cu}!cleanup\+\_\+solver@{cleanup\+\_\+solver}}
\index{cleanup\+\_\+solver@{cleanup\+\_\+solver}!exp4cu@{exp4cu}}
\subsubsection[{\texorpdfstring{cleanup\+\_\+solver(solver\+\_\+memory $\ast$$\ast$h\+\_\+mem, solver\+\_\+memory $\ast$$\ast$d\+\_\+mem)}{cleanup_solver(solver_memory **h_mem, solver_memory **d_mem)}}]{\setlength{\rightskip}{0pt plus 5cm}void exp4cu\+::cleanup\+\_\+solver (
\begin{DoxyParamCaption}
\item[{{\bf solver\+\_\+memory} $\ast$$\ast$}]{h\+\_\+mem, }
\item[{{\bf solver\+\_\+memory} $\ast$$\ast$}]{d\+\_\+mem}
\end{DoxyParamCaption}
)}\hypertarget{namespaceexp4cu_aa775ac1fc1a96522483d9878718cdbf2}{}\label{namespaceexp4cu_aa775ac1fc1a96522483d9878718cdbf2}


Cleans up solver memory. 

\begin{DoxySeeAlso}{See also}
\hyperlink{structexp4cu_1_1solver__memory}{solver\+\_\+memory} 

\hyperlink{solver__options_8cuh}{solver\+\_\+options.\+cuh}
\end{DoxySeeAlso}
Additionally closes Krylov subspace logfiles (if \hyperlink{solver__options_8h_ac786f5f1963363a48eed565f7cbc6931}{L\+O\+G\+\_\+\+O\+U\+T\+P\+UT} is defined) \index{exp4cu@{exp4cu}!create\+And\+Zero@{create\+And\+Zero}}
\index{create\+And\+Zero@{create\+And\+Zero}!exp4cu@{exp4cu}}
\subsubsection[{\texorpdfstring{create\+And\+Zero(void $\ast$$\ast$ptr, size\+\_\+t size)}{createAndZero(void **ptr, size_t size)}}]{\setlength{\rightskip}{0pt plus 5cm}void exp4cu\+::create\+And\+Zero (
\begin{DoxyParamCaption}
\item[{void $\ast$$\ast$}]{ptr, }
\item[{size\+\_\+t}]{size}
\end{DoxyParamCaption}
)}\hypertarget{namespaceexp4cu_abcdabb48b002afcaf4520f85bb06c156}{}\label{namespaceexp4cu_abcdabb48b002afcaf4520f85bb06c156}


Convienvience method to Cuda Malloc and memset a pointer to zero. 


\begin{DoxyParams}{Parameters}
{\em ptr} & The address of the pointer to malloc \\
\hline
{\em size} & The total size (in bytes) of the pointer to malloc \\
\hline
\end{DoxyParams}
\index{exp4cu@{exp4cu}!init\+\_\+solver\+\_\+log@{init\+\_\+solver\+\_\+log}}
\index{init\+\_\+solver\+\_\+log@{init\+\_\+solver\+\_\+log}!exp4cu@{exp4cu}}
\subsubsection[{\texorpdfstring{init\+\_\+solver\+\_\+log()}{init_solver_log()}}]{\setlength{\rightskip}{0pt plus 5cm}exp4cu\+::init\+\_\+solver\+\_\+log (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{namespaceexp4cu_a128b314d7c6b2521bbd64653dc8b9826}{}\label{namespaceexp4cu_a128b314d7c6b2521bbd64653dc8b9826}


Initializes solver specific items for logging. 

Initializes the Krylov subspace logging files (if \hyperlink{solver__options_8h_ac786f5f1963363a48eed565f7cbc6931}{L\+O\+G\+\_\+\+O\+U\+T\+P\+UT} is defined) \begin{DoxySeeAlso}{See also}
\hyperlink{solver__options_8cuh}{solver\+\_\+options.\+cuh} 
\end{DoxySeeAlso}
\index{exp4cu@{exp4cu}!initialize\+\_\+solver@{initialize\+\_\+solver}}
\index{initialize\+\_\+solver@{initialize\+\_\+solver}!exp4cu@{exp4cu}}
\subsubsection[{\texorpdfstring{initialize\+\_\+solver(int padded, solver\+\_\+memory $\ast$$\ast$h\+\_\+mem, solver\+\_\+memory $\ast$$\ast$d\+\_\+mem)}{initialize_solver(int padded, solver_memory **h_mem, solver_memory **d_mem)}}]{\setlength{\rightskip}{0pt plus 5cm}void exp4cu\+::initialize\+\_\+solver (
\begin{DoxyParamCaption}
\item[{int}]{padded, }
\item[{{\bf solver\+\_\+memory} $\ast$$\ast$}]{h\+\_\+mem, }
\item[{{\bf solver\+\_\+memory} $\ast$$\ast$}]{d\+\_\+mem}
\end{DoxyParamCaption}
)}\hypertarget{namespaceexp4cu_aa57e5681ad1b4e46c67d24d12d64e435}{}\label{namespaceexp4cu_aa57e5681ad1b4e46c67d24d12d64e435}


Initializes the G\+PU solver. 


\begin{DoxyParams}{Parameters}
{\em padded} & The total (padded) number of G\+PU threads (I\+V\+Ps) to solve \\
\hline
{\em h\+\_\+mem} & The host \hyperlink{structexp4cu_1_1solver__memory}{solver\+\_\+memory} structure (to be copied to the G\+PU) \\
\hline
{\em d\+\_\+mem} & The device \hyperlink{structexp4cu_1_1solver__memory}{solver\+\_\+memory} structure (to be operated on by the G\+PU)\\
\hline
\end{DoxyParams}
Solves for the poles and residuals used for the Rational Approximants in the Krylov subspace methods and initializes \hyperlink{structexp4cu_1_1solver__memory}{solver\+\_\+memory} \index{exp4cu@{exp4cu}!integrate@{integrate}}
\index{integrate@{integrate}!exp4cu@{exp4cu}}
\subsubsection[{\texorpdfstring{integrate(const double t\+\_\+start, const double t\+\_\+end, const double pr, double $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+ y, const mechanism\+\_\+memory $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+ mech, const solver\+\_\+memory $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+ solver)}{integrate(const double t_start, const double t_end, const double pr, double *__restrict__ y, const mechanism_memory *__restrict__ mech, const solver_memory *__restrict__ solver)}}]{\setlength{\rightskip}{0pt plus 5cm}int exp4cu\+::integrate (
\begin{DoxyParamCaption}
\item[{const double}]{t\+\_\+start, }
\item[{const double}]{t\+\_\+end, }
\item[{const double}]{pr, }
\item[{double $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+}]{y, }
\item[{const mechanism\+\_\+memory $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+}]{mech, }
\item[{const {\bf solver\+\_\+memory} $\ast$\+\_\+\+\_\+restrict\+\_\+\+\_\+}]{solver}
\end{DoxyParamCaption}
)}\hypertarget{namespaceexp4cu_aac3abe15ef50061cdfe24ed7d9d64b7a}{}\label{namespaceexp4cu_aac3abe15ef50061cdfe24ed7d9d64b7a}


4th-\/order exponential integrator function w/ adaptive Kyrlov subspace approximation 


\begin{DoxyParams}{Parameters}
{\em t\+\_\+start} & The initial integration time \\
\hline
{\em t\+\_\+end} & The final integration timestep \\
\hline
{\em pr} & User data passed to the R\+HS function dydt() -\/ commonly used for the Pressure term \\
\hline
{\em y} & The state vector \\
\hline
{\em mech} & The mechanism memory struct \\
\hline
{\em solver} & The solver memory struct \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result of this integration step (see enum in \hyperlink{exp4__props_8cuh}{exp4\+\_\+props.\+cuh}) will be stored in solver-\/$>$result for each thread 
\end{DoxyReturn}
\index{exp4cu@{exp4cu}!required\+\_\+solver\+\_\+size@{required\+\_\+solver\+\_\+size}}
\index{required\+\_\+solver\+\_\+size@{required\+\_\+solver\+\_\+size}!exp4cu@{exp4cu}}
\subsubsection[{\texorpdfstring{required\+\_\+solver\+\_\+size()}{required_solver_size()}}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t exp4cu\+::required\+\_\+solver\+\_\+size (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{namespaceexp4cu_a4d5db66ace53978d01e1975e47e30655}{}\label{namespaceexp4cu_a4d5db66ace53978d01e1975e47e30655}


Returns the total size (in bytes) required for memory storage for a single G\+PU thread Used in calculation of the maximum number of possible G\+PU threads to launch, this method returns the size of the \hyperlink{structexp4cu_1_1solver__memory}{solver\+\_\+memory} structure (per-\/\+G\+PU thread) 

\begin{DoxySeeAlso}{See also}
\hyperlink{structexp4cu_1_1solver__memory}{solver\+\_\+memory} 
\end{DoxySeeAlso}
\index{exp4cu@{exp4cu}!solver\+\_\+log@{solver\+\_\+log}}
\index{solver\+\_\+log@{solver\+\_\+log}!exp4cu@{exp4cu}}
\subsubsection[{\texorpdfstring{solver\+\_\+log()}{solver_log()}}]{\setlength{\rightskip}{0pt plus 5cm}exp4cu\+::solver\+\_\+log (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{namespaceexp4cu_a042f555823c136890f60ab28454daf9e}{}\label{namespaceexp4cu_a042f555823c136890f60ab28454daf9e}


Executes solver specific logging tasks. 

Logs errors, step-\/sizes, and krylov subspace size (if \hyperlink{solver__options_8h_ac786f5f1963363a48eed565f7cbc6931}{L\+O\+G\+\_\+\+O\+U\+T\+P\+UT} is defined) \begin{DoxySeeAlso}{See also}
\hyperlink{solver__options_8cuh}{solver\+\_\+options.\+cuh} 
\end{DoxySeeAlso}
\index{exp4cu@{exp4cu}!solver\+\_\+name@{solver\+\_\+name}}
\index{solver\+\_\+name@{solver\+\_\+name}!exp4cu@{exp4cu}}
\subsubsection[{\texorpdfstring{solver\+\_\+name()}{solver_name()}}]{\setlength{\rightskip}{0pt plus 5cm}char $\ast$ exp4cu\+::solver\+\_\+name (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{namespaceexp4cu_ad9fad26aa869ef1c6b7fc061e1e6abc3}{}\label{namespaceexp4cu_ad9fad26aa869ef1c6b7fc061e1e6abc3}


Returns a descriptive solver name. 

