<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>accelerInt: The van der Pol problem</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="styles.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">accelerInt
   &#160;<span id="projectnumber">v0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The van der Pol problem </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The van der Pol problem is a commonly used stiff test problem for ODE solvers. The stiffness is 'tunable' via modification of parameter <img class="formulaInl" alt="$\mu$" src="form_38.png"/> A complete reference can be found in: </p><pre class="fragment">    Hairer, Noersett, Wanner: Solving Ordinary Differential Equations II, p 157. Springer-Verlag 1991.
</pre><p> or for a practical example in Matlab, <a href="http://www.ece.northwestern.edu/local-apps/matlabhelp/techdoc/math_anal/diffeq6.html">see here</a>.</p>
<h1><a class="anchor" id="defn"></a>
Problem Definition</h1>
<p>The van der Pol problem can be written as a set of two first-order of non-linear ODE equations:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align} &amp; y_1^\prime =&amp;&amp; y_2 \, &amp; y_1(0) =&amp;&amp; y_1^\circ \nonumber \\ &amp; y_2^\prime =&amp;&amp; \mu \left(1 - y_1^2y_2\right) - y_1 \, &amp; y_2(0) =&amp;&amp; y_2^\circ \nonumber \end{align}" src="form_39.png"/>
</p>
<p>For our purposes, we shall use:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align} y_1^\circ &amp;= 2 \nonumber \\ y_2^\circ &amp;= 0 \nonumber \\ \mu&amp;= 1000 \nonumber \end{align}" src="form_40.png"/>
</p>
<p>for <a href="http://www.ece.northwestern.edu/local-apps/matlabhelp/techdoc/math_anal/diffeq6.html#37714">comparison purposes</a></p>
<h1><a class="anchor" id="accelerint_indx"></a>
A Note on Indexing</h1>
<p>The format of arrays expected by <code>accelerInt</code> is of note.</p>
<dl class="section attention"><dt>Attention</dt><dd>In all cases, the C-solvers operate on local copies of the state vectors and Jacobian matrix. This means that the problem index (i.e. which IVP is being solved) does not enter into vector or matrix indexing. The memory layout is still a Column-major format for the Jacobian matrix. To see an example of proper Jacobian layout and indexing for C-solvers, see <a class="el" href="jacob_8c.html" title="An implementation of the van der Pol jacobian . ">jacob.c</a></dd>
<dd>
In the CUDA case however, the state vectors and Jacobian matrix remain in global memory by necessity due to limitations on the size of local memory per-thread. Here, the IVP index does factor into indexing concerns, and can be accessed using the built-in CUDA thread indexing parameters (e.g. <code>threadIdx.x</code>, etc.). For an example of Jacobian layout and indexing for the CUDA-case, see jacob.cu.</dd></dl>
<h1><a class="anchor" id="impl"></a>
Implementation</h1>
<p>This section details the implementation files required for the C and CUDA solvers.</p>
<h2><a class="anchor" id="rhs"></a>
RHS implementation</h2>
<p>First, both languages need a <a class="el" href="namespacevan__der__pol.html#a96995d7e4edc13c1ef284c49539a8eb6" title="An implementation of the RHS of the van der Pol equation. ">dydt()</a> function implementation. Both a header and implementation file are required.</p><ul>
<li>For the C-solvers, the implementation is in <a class="el" href="dydt_8c.html" title="An implementation of the van der Pol right hand side (y&#39; = f(y)) function. ">dydt.c</a> and the header definition in <a class="el" href="dydt_8h.html" title="Contains header definitions for the RHS function for the van der Pol example. ">dydt.h</a></li>
</ul>
<h2><a class="anchor" id="jac"></a>
Jacobian</h2>
<p>If <a class="el" href="solver__options_8h.html#a9e28db46fb24c2d46dbfe205c6a11236">FINITE_DIFFERENCE</a> is not specified in the <a class="el" href="scons_opts.html">SCons Options</a>, an analytical Jacobian implementation must be must be specified. Both a header and implementation file are required:</p><ul>
<li>See <a class="el" href="jacob_8h.html" title="Contains a header definition for the van der Pol Jacobian evaluation. ">jacob.h</a> and <a class="el" href="jacob_8c.html" title="An implementation of the van der Pol jacobian . ">jacob.c</a> for the C-solvers</li>
</ul>
<h2><a class="anchor" id="header"></a>
System Header</h2>
<p>The ODE <a class="el" href="header_8h.html" title="An example header file that defines system size and other required methods for integration of the van...">header.h</a> file contains several important macros and definitions.</p><ul>
<li>First, the macro <a class="el" href="header_8h.html#aa86864581d2574ded23a182874b81f4c" title="The IVP system size. ">NSP</a> defines the number of variables in the state vector, i.e. 2 for this problem.</li>
<li>Second the macro <a class="el" href="header_8h.html#a170755e30c36be4904106b7bb279b1ec" title="Input vector size (in read_initial_conditions) ">NN</a> should be defined to be equal to <a class="el" href="header_8h.html#aa86864581d2574ded23a182874b81f4c" title="The IVP system size. ">NSP</a>. See <a class="el" href="vdp.html#ics">Initial Conditions</a> for more information.</li>
</ul>
<p>The <a class="el" href="header_8h.html" title="An example header file that defines system size and other required methods for integration of the van...">header.h</a> file also contains header definitions for several functions dealing with initial conditions, <a class="el" href="namespacevan__der__pol.html#a9ba2f557863eba74497be28e9ad5ca7f" title="Set same ICs for all problems. ">set_same_initial_conditions()</a>, <a class="el" href="namespacevan__der__pol.html#acc700a326aa10b0c7fdcb2e6841d7a0c" title="Not needed for van der Pol. ">apply_mask()</a> and <a class="el" href="namespacevan__der__pol.html#a3f75eefd8f83fd4adfe62a27d5ad95cd" title="Not needed for van der Pol. ">apply_reverse_mask()</a>.</p>
<h2><a class="anchor" id="ics"></a>
Initial Conditions</h2>
<p>The initial condition reader was designed with <a href="http://slackha.github.io/pyJac/" title="pyJac Documentation" target="_blank">pyJac</a> in mind, it is currently quite cumbersome to use for other data formats.</p>
<ul>
<li>Although this will be upgraded in future releases, currently the <a class="el" href="header_8h.html#a170755e30c36be4904106b7bb279b1ec" title="Input vector size (in read_initial_conditions) ">NN</a> macro should be defined to be equal to <a class="el" href="header_8h.html#aa86864581d2574ded23a182874b81f4c" title="The IVP system size. ">NSP</a>.</li>
<li><p class="startli">Additionally, the initial conditions reader expects the following data format:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align} \nonumber \text{time}, y_1, \text{parameter}, y_2,&amp; y_3, ... y_{NSP} \text{ (State 1)}\\ \nonumber \text{time}, y_1, \text{parameter}, y_2,&amp; y_3, ... y_{NSP} \text{ (State 2)}\\ \nonumber \vdots&amp; \end{align}" src="form_41.png"/>
</p>
<p> An example of how to write a file in this format can be found in <a class="el" href="generate__ics_8py.html" title="Generates initial conditions file for van der Pol problem. ">generate_ics.py</a></p>
</li>
</ul>
<p>The <a class="el" href="namespacevan__der__pol.html#a9ba2f557863eba74497be28e9ad5ca7f" title="Set same ICs for all problems. ">set_same_initial_conditions()</a>, defined in <a class="el" href="ics_8c.html" title="Sets same Initial Conditions (ICs) for all problems. ">ics.c</a> defines a simple function to set the initial conditions of the state vector if the <a class="el" href="scons_opts.html">SCons option</a> <a class="el" href="solver__options_8h.html#aa98acf0dc83a3dce3ba168d75a74cb1b">SAME_IC</a> is used.</p><ul>
<li>In this case, we use this method to set the initial conditions described in <a class="el" href="vdp.html#defn">Problem Definition</a>.</li>
</ul>
<p>Additionally, <a class="el" href="ics_8c.html" title="Sets same Initial Conditions (ICs) for all problems. ">ics.c</a> defines the dummy methods <a class="el" href="namespacevan__der__pol.html#acc700a326aa10b0c7fdcb2e6841d7a0c" title="Not needed for van der Pol. ">apply_mask()</a> and <a class="el" href="namespacevan__der__pol.html#a3f75eefd8f83fd4adfe62a27d5ad95cd" title="Not needed for van der Pol. ">apply_reverse_mask()</a>, which are not used for the van der Pol problem.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="read__initial__conditions_8c.html" title="the generic initial condition reader ">read_initial_conditions.c</a>, <a class="el" href="read__initial__conditions_8cu.html" title="the generic CUDA initial condition reader ">read_initial_conditions.cu</a></dd></dl>
<h2><a class="anchor" id="mult"></a>
Matrix-Vector Multiplier</h2>
<p>Finally, the fine <a class="el" href="sparse__multiplier_8c.html" title="Implementation for Jacobian vector multiplication, used in exponential integrators. ">sparse_multiplier.c</a> and <a class="el" href="sparse__multiplier_8h.html" title="Header definition for Jacobian vector multiplier, used in exponential integrators. ">sparse_multiplier.h</a> provide definitions for a "sparse" (unrolled) matrix multiplier. This is used by the exponential solvers (and may provide speedups if a sparse Jacobian is used).</p>
<h1><a class="anchor" id="compilation"></a>
Compiling the van der Pol problem.</h1>
<p>We compile the problem with the SCons call: </p><pre class="fragment">    scons SAME_IC=True LOG_OUTPUT=True LOG_END_ONLY=False t_end=2000 t_step=1
</pre><p>This turns on the initial conditions discussed in <a class="el" href="vdp.html#defn">Problem Definition</a>.</p>
<ul>
<li>We log the output to a file (generated by default in <code>accelerInt-root/log/solvername.bin</code>), for plotting.<br />
</li>
<li>The time step <a class="el" href="solver__options_8h.html#aaeb7127cf3bf0b49cec6554fbc101866">t_step</a> is set to 1 second, while the end time <a class="el" href="solver__options_8h.html#a25526ead9bdb589c90e7a8d3b4d1a746">end_time</a> is set to 2000 seconds.</li>
<li>The default error tolerances <a class="el" href="solver__options_8h.html#a29a15cd00b37b1f4a5b4ec9f07c742f4">ATOL</a>/<a class="el" href="solver__options_8h.html#af50ac611d9fae906f9419504fd2caa5d">RTOL</a> = <img class="formulaInl" alt="$\num{e-10}\text{ and }\num{e-6}$" src="form_42.png"/> respectively are used.</li>
<li>Additionaly the <a class="el" href="solver__options_8h.html#a8b43bafee90b30676faae508c21cb8d7">PRINT</a>=True option tuns on logging to the screen (if so desired)</li>
<li>Alternatively, randomized initial conditions generated by <a class="el" href="generate__ics_8py.html" title="Generates initial conditions file for van der Pol problem. ">generate_ics.py</a> may be used by copying the resulting <code>ign_data.bin</code> file to the root <code>accelerInt</code> folder, and compiling without the <a class="el" href="solver__options_8h.html#aa98acf0dc83a3dce3ba168d75a74cb1b">SAME_IC</a> option.</li>
</ul>
<h1><a class="anchor" id="results"></a>
Calling the Solvers and Plotting Results</h1>
<p>The CPU solvers can be called using: </p><pre class="fragment">    ./solver_name [num_threads] [num_odes]
</pre><p>While the GPU solvers are called via: </p><pre class="fragment">    ./solver_name [num_odes]
</pre><p>For example, we call: </p><pre class="fragment">    ./exprb43-int 1 1
    ./cvodes-int 1 1
    ./radau2a-int 1 1
</pre><p>Next, we load the data and plot (<a class="el" href="plotter_8py.html">plotter.py</a>), resulting in:</p>
<div class="image">
<img src="van_der_pol.png" alt="van_der_pol.png"/>
<div class="caption">
Solver output for the van der Pol problem</div></div>
 </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
