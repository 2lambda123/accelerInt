<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>accelerInt: The van der Pol problem</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="styles.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">accelerInt
   &#160;<span id="projectnumber">v0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The van der Pol problem </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The van der Pol problem is a commonly used stiff test problem for ODE solvers. The stiffness is 'tunable' via modification of parameter \(\mu\) A complete reference can be found in: </p><pre class="fragment">    Hairer, Noersett, Wanner: Solving Ordinary Differential Equations II, p 157. Springer-Verlag 1991.
</pre><p> or for a practical example in Matlab, <a href="http://www.ece.northwestern.edu/local-apps/matlabhelp/techdoc/math_anal/diffeq6.html">see here</a>.</p>
<h1><a class="anchor" id="defn"></a>
Problem Definition</h1>
<p>The van der Pol problem can be written as a set of two first-order of non-linear ODE equations:</p>
<p class="formulaDsp">
\begin{align} &amp; y_1^\prime =&amp;&amp; y_2 \, &amp; y_1(0) =&amp;&amp; y_1^\circ \nonumber \\ &amp; y_2^\prime =&amp;&amp; \mu \left(1 - y_1^2\right)y_2 - y_1 \, &amp; y_2(0) =&amp;&amp; y_2^\circ \nonumber \end{align}
</p>
<p>For our purposes, we shall use:</p>
<p class="formulaDsp">
\begin{align} y_1^\circ &amp;= 2 \nonumber \\ y_2^\circ &amp;= 0 \nonumber \\ \mu&amp;= 1000 \nonumber \end{align}
</p>
<p>for <a href="http://www.ece.northwestern.edu/local-apps/matlabhelp/techdoc/math_anal/diffeq6.html#37714">comparison purposes</a></p>
<h1><a class="anchor" id="accelerint_indx"></a>
A Note on Indexing</h1>
<h2><a class="anchor" id="C-Indexing"></a>
C-Indexing</h2>
<p>The format of arrays expected by <code>accelerInt</code> is of note.</p>
<dl class="section note"><dt>Note</dt><dd>In all cases, the C-solvers operate on local copies of the state vectors and Jacobian matrix. This means that the problem index (i.e. which IVP is being solved) does not enter into vector or matrix indexing.</dd></dl>
<p>The expected Jacobian ordering for the C-solvers follows <a href="http://slackha.github.io/pyJac/faqs.html#what-is-in-the-jacobian">pyJac v1's jacobian pattern</a>, that is:</p>
<p class="formulaDsp">
\begin{align} \mathcal{J}_{i, j} &amp;= \frac{ \partial y_i^\prime } { \partial y_j } \end{align}
</p>
<p>Pratically speaking, for the van der Pol problem, this translates to the Jacobian: </p><p class="formulaDsp">
\begin{align} \mathcal{J} &amp; = \left[ \begin{array}{cc} \frac {\partial y_1^\prime } {\partial y_1} &amp; \frac {\partial y_1^\prime } {\partial y_2} \\ \frac {\partial y_2^\prime } {\partial y_1} &amp; \frac {\partial y_2^\prime } {\partial y_2} \end{array} \right] \end{align}
</p>
<p>This is then flattened in column-major (F) order, such that the flatten Jacobian array reads:</p>
<p class="formulaDsp">
\begin{align} \vec{\mathcal{J}} &amp; = \left\{ \frac {\partial y_1^\prime } {\partial y_1}, \frac {\partial y_2^\prime } {\partial y_1}, \frac {\partial y_1^\prime } {\partial y_2}, \frac {\partial y_2^\prime } {\partial y_2} \right\} \end{align}
</p>
<p>This ordering can be seen in action in <a class="el" href="namespacevan__der__pol.html#a591a205f3018bef87815bb37655028e8" title="An implementation of the van der Pol jacobian. ">van_der_pol.eval_jacob()</a></p>
<h2><a class="anchor" id="accelerint_indx_cuda"></a>
CUDA indexing</h2>
<p>For CUDA, the state-vector and Jacobian arrays remain in global memory by necessity due to limitations on the size of local memory per-thread. Here, the IVP index does factor into indexing concerns, and can be accessed using the built-in CUDA thread indexing parameters (e.g. <code>threadIdx.x</code>, etc.).</p>
<dl class="section note"><dt>Note</dt><dd>Convienience macros are defined in <a class="el" href="gpu__macros_8cuh.html" title="Defines some simple macros to simplify GPU indexing. ">gpu_macros.cuh</a> to aid indexing; for an example of Jacobian layout and indexing for the CUDA-case, see <a class="el" href="jacob_8cu.html" title="A CUDA implementation of the van der Pol jacobian . ">jacob.cu</a>.</dd></dl>
<p>Let's say we are solving \(N_{p}\) separate problems (e.g., differing initial conditions, stiffness parameter, etc.). Our Jacobian is now transformed to:</p>
<p class="formulaDsp">
\begin{align} \mathcal{J}_{n, i, j} &amp;= \frac{ \partial y_{n, i}^\prime } { \partial y_{n, j} } \end{align}
</p>
<p>where \(y_{n, i}$\) is the <em>i</em>-th entry in the state vector of the <em>n</em>-th problem. Our Jacobian is again flattened in column major order, such that the flat vector is:</p>
<p class="formulaDsp">
\begin{align} \vec{\mathcal{J}} &amp; = \left\{ \frac {\partial y_{1, 1}^\prime } {\partial y_{1, 1}}, \frac {\partial y_{2, 1}^\prime } {\partial y_{2, 1}}, \ldots, \frac {\partial y_{N_{p}, 1}^\prime } {\partial y_{N_{p}, 1}}, \frac {\partial y_{1, 2}^\prime } {\partial y_{1, 1}}, \frac {\partial y_{2, 2}^\prime } {\partial y_{2, 1}}, \ldots \frac {\partial y_{N_{p}, 2}^\prime } {\partial y_{N_{p}, 1}}, \frac {\partial y_{1, 2}^\prime } {\partial y_{1, 1}}, \ldots \frac {\partial y_{N_{p}, 2}^\prime } {\partial y_{N_{p}, 2}} \right\} \end{align}
</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="gpu__macros_8cuh.html#aa5fad23b2a5eed790e6661e896a506b7" title="Convenience macro to get the value of a vector at index i, calculated as i * GRID_DIM + T_ID...">INDEX</a>, <a class="el" href="gpu__macros_8cuh.html" title="Defines some simple macros to simplify GPU indexing. ">gpu_macros.cuh</a>, <a class="el" href="jacob_8cu.html" title="A CUDA implementation of the van der Pol jacobian . ">jacob.cu</a></dd></dl>
<h1><a class="anchor" id="impl"></a>
Implementation</h1>
<p>This section details the implementation files required for the C and CUDA solvers.</p>
<h2><a class="anchor" id="rhs"></a>
RHS implementation</h2>
<p>First, both languages need a <a class="el" href="namespacevan__der__pol.html#a96995d7e4edc13c1ef284c49539a8eb6" title="An implementation of the RHS of the van der Pol equation. ">dydt()</a> function implementation. Both a header and implementation file are required.</p><ul>
<li>For the C-solvers, the implementation is in <a class="el" href="dydt_8c.html" title="An implementation of the van der Pol right hand side (y&#39; = f(y)) function. ">dydt.c</a> and the header definition in <a class="el" href="dydt_8h.html" title="Contains header definitions for the RHS function for the van der Pol example. ">dydt.h</a></li>
<li>For the CUDA-sovlers, the implementation and headers are <a class="el" href="dydt_8cu.html" title="A CUDA implementation of the van der Pol right hand side (y&#39; = f(y)) function. ">dydt.cu</a> and <a class="el" href="dydt_8cuh.html" title="Contains header definitions for the CUDA RHS function for the van der Pol example. ">dydt.cuh</a> respectively.</li>
</ul>
<h2><a class="anchor" id="jac"></a>
Jacobian</h2>
<p>If <a class="el" href="solver__options_8h.html#a9e28db46fb24c2d46dbfe205c6a11236">FINITE_DIFFERENCE</a> is not specified in the <a class="el" href="scons_opts.html">SCons Options</a>, an analytical Jacobian implementation must be must be specified. Both a header and implementation file are required:</p><ul>
<li>See <a class="el" href="jacob_8h.html" title="Contains a header definition for the van der Pol Jacobian evaluation. ">jacob.h</a> and <a class="el" href="jacob_8c.html" title="An implementation of the van der Pol jacobian . ">jacob.c</a> for the C-solvers</li>
<li>See <a class="el" href="jacob_8cuh.html" title="Contains a header definition for the CUDA van der Pol Jacobian evaluation. ">jacob.cuh</a> and <a class="el" href="jacob_8cu.html" title="A CUDA implementation of the van der Pol jacobian . ">jacob.cu</a> for the C-solvers</li>
</ul>
<h2><a class="anchor" id="header"></a>
System Header</h2>
<p>The ODE <a class="el" href="header_8h.html" title="An example header file that defines system size and other required methods for integration of the van...">header.h</a> file contains several important macros and definitions.</p><ul>
<li>First, the macro <a class="el" href="header_8h.html#aa86864581d2574ded23a182874b81f4c" title="The IVP system size. ">NSP</a> defines the number of variables in the state vector, i.e. 2 for this problem.</li>
<li>Second the macro <a class="el" href="header_8h.html#a170755e30c36be4904106b7bb279b1ec" title="Input vector size (in read_initial_conditions) ">NN</a> should be defined to be equal to <a class="el" href="header_8h.html#aa86864581d2574ded23a182874b81f4c" title="The IVP system size. ">NSP</a>. See <a class="el" href="vdp.html#ics">Initial Conditions</a> for more information.</li>
</ul>
<p>The <a class="el" href="header_8h.html" title="An example header file that defines system size and other required methods for integration of the van...">header.h</a> file also contains header definitions for several functions dealing with initial conditions, <a class="el" href="namespacevan__der__pol__cu.html#aa12c20164ea5113a104bfe974fa7147a" title="Set same ICs for all problems. ">set_same_initial_conditions()</a>, <a class="el" href="namespacevan__der__pol__cu.html#a7faee9f3588766e9cfe7c741dab3ee9b" title="Not needed for van der Pol. ">apply_mask()</a> and <a class="el" href="namespacevan__der__pol__cu.html#a0bf56007d0b7d30d68223d2febfcc090" title="Not needed for van der Pol. ">apply_reverse_mask()</a>.</p>
<p>The CUDA <a class="el" href="header_8cuh.html" title="An example header file that defines system size, memory functions and other required methods for inte...">header.cuh</a> file is similar to the C-version, with a few additional methods regarding <a class="el" href="vdp.html#GPU_mem">GPU Memory Initialization</a>. It contains the <a class="el" href="structvan__der__pol__cu_1_1mechanism__memory.html">mechanism_memory struct</a>, which defines memory needed for RHS and Jacobian evaluation, as well as the <a class="el" href="namespacevan__der__pol__cu.html#a335500438eecc1a53d27911bdb50bd6e" title="Initializes the host and device mechanism_memory structs. This is required in order to enable passing...">initialize_gpu_memory()</a>, <a class="el" href="namespacevan__der__pol__cu.html#a40f4f15256b20b377f4b76c325eceae2" title="Frees the host and device mechanism_memory structs. ">free_gpu_memory()</a>, and <a class="el" href="namespacevan__der__pol__cu.html#ad0a58342699dfa097a60b242293f4934" title="Calculates and returns the total memory size (in bytes) required by an individual thread for the mech...">required_mechanism_size()</a> methods, which initialize, free and calculate the required GPU memory respectively.</p>
<h2><a class="anchor" id="GPU_mem"></a>
GPU Memory Initialization</h2>
<p>In order to operate the CUDA solvers, the user must implement some additional functions designed to properly initialize the required GPU memory. <code>accelerInt</code> pre-allocates the required memory for the solver and ODE model in the GPU's global memory to get around use of local per-thread (stack) memory allocation which becomes limiting for large ODE systems.</p>
<ul>
<li><a class="el" href="namespacevan__der__pol__cu.html#ad0a58342699dfa097a60b242293f4934" title="Calculates and returns the total memory size (in bytes) required by an individual thread for the mech...">required_mechanism_size()</a> determines the amount of memory (in bytes) required per each individual CUDA thread. This is used to determine the maximum number of threads that can be launched per GPU and to split integration into batches if necessary. This is similar to the various <a class="el" href="namespacegenericcu.html#a95e70ae54ccfc5eb00792846ca80ecde" title="Returns the total size (in bytes) required for memory storage for a single GPU thread Used in calcula...">required_solver_size()</a> implementations for the solvers.</li>
<li><a class="el" href="namespacevan__der__pol__cu.html#a335500438eecc1a53d27911bdb50bd6e" title="Initializes the host and device mechanism_memory structs. This is required in order to enable passing...">initialize_gpu_memory()</a> initializes the host and device versions of the mechanism_memory structs, similar to the various <a class="el" href="namespacecvode.html#abe146525cea80d8032cd30b4441b5872" title="Initializes the solver. ">initialize_solver()</a> implementations for the GPU solvers</li>
<li><a class="el" href="namespacevan__der__pol__cu.html#a40f4f15256b20b377f4b76c325eceae2" title="Frees the host and device mechanism_memory structs. ">free_gpu_memory()</a> cleans up the host and device mechanism_memory structs as with the <a class="el" href="namespacecvode.html#ac9bc4957bff6721dae9d7e4cc470d184" title="Cleans up the created solvers. ">cleanup_solver()</a> implementation for each GPU solver.</li>
</ul>
<h2><a class="anchor" id="launch"></a>
GPU Launch Bounds</h2>
<p>The <a class="el" href="launch__bounds_8cuh.html" title="A number of definitions that control CUDA kernel launches. ">launch_bounds.cuh</a> file contains definitions for a few variables that control CUDA kernel launches:</p><ul>
<li><a class="el" href="launch__bounds_8cuh.html#ae53274b00308b1ad9b200ad750383abd" title="The target number of threads per block. ">TARGET_BLOCK_SIZE</a> defines the number of threads per CUDA block</li>
<li><a class="el" href="launch__bounds_8cuh.html#a232fb4f165a3ecb4a9e5f2a7f1f45a19" title="Shared memory per thread. ">SHARED_SIZE</a> defines the size of shared memory per CUDA block. This is not currently used by the solvers, but could potentially be used by a used defined RHS / Jacobian implementation.</li>
<li><a class="el" href="launch__bounds_8cuh.html#a878b153e37b2bb9282f21760e71b7103" title="Large L1 cache active. ">PREFERL1</a> tells CUDA to prefer a larger L1 cache over more shared memory. It is recommended to keep this on.</li>
</ul>
<h2><a class="anchor" id="ics"></a>
Initial Conditions</h2>
<p>The initial condition reader was designed with <a href="http://slackha.github.io/pyJac/" title="pyJac Documentation" target="_blank">pyJac</a> in mind, it is currently quite cumbersome to use for other data formats.</p>
<ul>
<li>Although this will be upgraded in future releases, currently the <a class="el" href="header_8h.html#a170755e30c36be4904106b7bb279b1ec" title="Input vector size (in read_initial_conditions) ">NN</a> macro should be defined to be equal to <a class="el" href="header_8h.html#aa86864581d2574ded23a182874b81f4c" title="The IVP system size. ">NSP</a>.</li>
<li><p class="startli">Additionally, the initial conditions reader expects the following data format:</p>
<p class="formulaDsp">
\begin{align} \nonumber \text{time}, y_1, \text{parameter}, y_2,&amp; y_3, ... y_{NSP} \text{ (State 1)}\\ \nonumber \text{time}, y_1, \text{parameter}, y_2,&amp; y_3, ... y_{NSP} \text{ (State 2)}\\ \nonumber \vdots&amp; \end{align}
</p>
<p> An example of how to write a file in this format can be found in <a class="el" href="generate__ics_8py.html" title="Generates initial conditions file for van der Pol problem. ">generate_ics.py</a></p>
</li>
</ul>
<p>The <a class="el" href="namespacevan__der__pol__cu.html#aa12c20164ea5113a104bfe974fa7147a" title="Set same ICs for all problems. ">set_same_initial_conditions()</a>, defined in <a class="el" href="ics_8c.html" title="Sets same Initial Conditions (ICs) for all problems. ">ics.c</a> and <a class="el" href="ics_8cu.html" title="Sets same Initial Conditions (ICs) for all problems. ">ics.cu</a> defines a simple function to set the initial conditions of the state vector if the <a class="el" href="scons_opts.html">SCons option</a> <a class="el" href="solver__options_8h.html#aa98acf0dc83a3dce3ba168d75a74cb1b">SAME_IC</a> is used.</p><ul>
<li>In this case, we use this method to set the initial conditions described in <a class="el" href="vdp.html#defn">Problem Definition</a>.</li>
</ul>
<p>Additionally, <a class="el" href="ics_8c.html" title="Sets same Initial Conditions (ICs) for all problems. ">ics.c</a> / <a class="el" href="ics_8cu.html" title="Sets same Initial Conditions (ICs) for all problems. ">ics.cu</a> defines the dummy methods <a class="el" href="namespacevan__der__pol__cu.html#a7faee9f3588766e9cfe7c741dab3ee9b" title="Not needed for van der Pol. ">apply_mask()</a> and <a class="el" href="namespacevan__der__pol__cu.html#a0bf56007d0b7d30d68223d2febfcc090" title="Not needed for van der Pol. ">apply_reverse_mask()</a>, which are not used for the van der Pol problem.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="read__initial__conditions_8c.html" title="the generic initial condition reader ">read_initial_conditions.c</a>, <a class="el" href="read__initial__conditions_8cu.html" title="the generic CUDA initial condition reader ">read_initial_conditions.cu</a></dd></dl>
<h2><a class="anchor" id="mult"></a>
Matrix-Vector Multiplier</h2>
<p>Finally, the <a class="el" href="sparse__multiplier_8c.html" title="Implementation for Jacobian vector multiplication, used in exponential integrators. ">sparse_multiplier.c</a>, <a class="el" href="sparse__multiplier_8cu.html" title="Implementation for CUDA Jacobian vector multiplication, used in exponential integrators. ">sparse_multiplier.cu</a>, <a class="el" href="sparse__multiplier_8h.html" title="Header definition for Jacobian vector multiplier, used in exponential integrators. ">sparse_multiplier.h</a> and <a class="el" href="sparse__multiplier_8cuh.html" title="Header definition for CUDA Jacobian vector multiplier, used in exponential integrators. ">sparse_multiplier.cuh</a> provide headers and definitions for a "sparse" (unrolled) matrix multiplier. This is used by the exponential solvers (and may provide speedups if a sparse Jacobian is used).</p>
<h1><a class="anchor" id="compilation"></a>
Compiling the van der Pol problem.</h1>
<p>We compile the problem with the SCons call: </p><pre class="fragment">    scons SAME_IC=True LOG_OUTPUT=True LOG_END_ONLY=False t_end=2000.0 t_step=1.0 mechanism_dir=examples/van_der_pol/ -j 2
</pre><p>This turns on the initial conditions discussed in <a class="el" href="vdp.html#defn">Problem Definition</a>.</p>
<ul>
<li>The <code>j</code> parameter allows scons to use 2 threads during compilation (vary as necessary)</li>
<li>The <code>mechanism_dir</code> option tells scons to look in the <code><a class="el" href="namespacevan__der__pol.html">van_der_pol</a></code> example directory for <a class="el" href="vdp.html#impl">Implementation</a> implementation of the required functions described above.</li>
<li>We log the output to a file (generated by default in <code>accelerInt-root/log/solvername.bin</code>), for plotting.<br />
</li>
<li>The time step (<a class="el" href="solver__options_8h.html#aaeb7127cf3bf0b49cec6554fbc101866">t_step</a>) is set to 1 second, while the end time (<a class="el" href="solver__options_8h.html#a25526ead9bdb589c90e7a8d3b4d1a746">end_time</a>) is set to 2000 seconds.</li>
<li>The default error tolerances <a class="el" href="solver__options_8h.html#a29a15cd00b37b1f4a5b4ec9f07c742f4">ATOL</a>/<a class="el" href="solver__options_8h.html#af50ac611d9fae906f9419504fd2caa5d">RTOL</a> = 10<sup>-10</sup> and 10<sup>-6</sup> respectively are used.</li>
<li>Additionaly the <a class="el" href="solver__options_8h.html#a8b43bafee90b30676faae508c21cb8d7">PRINT</a>=True option tuns on logging to the screen (if so desired)</li>
<li>Alternatively, randomized initial conditions generated by <a class="el" href="generate__ics_8py.html" title="Generates initial conditions file for van der Pol problem. ">generate_ics.py</a> may be used by copying the resulting <code>ign_data.bin</code> file to the root <code>accelerInt</code> folder, and compiling without the <a class="el" href="solver__options_8h.html#aa98acf0dc83a3dce3ba168d75a74cb1b">SAME_IC</a> option.</li>
</ul>
<h1><a class="anchor" id="results"></a>
Running the Solvers and Plotting Results</h1>
<p>The CPU solvers can be called using: </p><pre class="fragment">    ./solver_name [num_threads] [num_odes]
</pre><p>While the GPU solvers are called via: </p><pre class="fragment">    ./solver_name [num_odes]
</pre><p>For example, we call: </p><pre class="fragment">    ./exprb43-int-gpu 1
    ./cvodes-int 1 1
    ./radau2a-int 1 1
</pre><p>Next, we load the data and plot (plotter.py), resulting in:</p>
<div class="image">
<img src="van_der_pol.png" alt="van_der_pol.png" width="10cm"/>
<div class="caption">
Solver output for the van der Pol problem</div></div>
 </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
